<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Embedded Co-Design (VHDL and C): xQueueSendFromISR</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>xQueueSendFromISR</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
</table>
<p>queue. h </p>
<pre>
 portBASE_TYPE xQueueSendToFrontFromISR(
										 xQueueHandle pxQueue,
										 const void *pvItemToQueue,
										 portBASE_TYPE *pxHigherPriorityTaskWoken
									  );
 </pre><p>This is a macro that calls <a class="el" href="queue_8h.html#a5f3e29eed8f166215648bc6465ebdb04">xQueueGenericSendFromISR()</a>.</p>
<p>Post an item to the front of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xQueue</em>&nbsp;</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvItemToQueue</em>&nbsp;</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pxHigherPriorityTaskWoken</em>&nbsp;</td><td><a class="el" href="queue_8h.html#a849dd669e72bfb12314f4445157c9a04">xQueueSendToFrontFromISR()</a> will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToFromFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<pre>
 void vBufferISR( void )
 {
 char cIn;
 portBASE_TYPE xHigherPrioritTaskWoken;</pre><pre>We have not woken a task at the start of the ISR.
	xHigherPriorityTaskWoken = pdFALSE;</pre><pre>Loop until the buffer is empty.
	do
	{
Obtain a byte from the buffer.
		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</pre><pre>Post the byte.
		<a class="el" href="queue_8h.html#a849dd669e72bfb12314f4445157c9a04">xQueueSendToFrontFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken )</a>;</pre><pre>	} while( portINPUT_BYTE( BUFFER_COUNT ) );</pre><pre>Now the buffer is empty we can switch context if necessary.
	if( xHigherPriorityTaskWoken )
	{
		taskYIELD ();
	}
 }
 </pre><p>queue. h </p>
<pre>
 portBASE_TYPE xQueueSendToBackFromISR(
										 xQueueHandle pxQueue,
										 const void *pvItemToQueue,
										 portBASE_TYPE *pxHigherPriorityTaskWoken
									  );
 </pre><p>This is a macro that calls <a class="el" href="queue_8h.html#a5f3e29eed8f166215648bc6465ebdb04">xQueueGenericSendFromISR()</a>.</p>
<p>Post an item to the back of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xQueue</em>&nbsp;</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvItemToQueue</em>&nbsp;</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pxHigherPriorityTaskWoken</em>&nbsp;</td><td><a class="el" href="queue_8h.html#a5a4b46fc55ab9f63b89878b37352f521">xQueueSendToBackFromISR()</a> will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If <a class="el" href="queue_8h.html#a5a4b46fc55ab9f63b89878b37352f521">xQueueSendToBackFromISR()</a> sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<pre>
 void vBufferISR( void )
 {
 char cIn;
 portBASE_TYPE xHigherPriorityTaskWoken;</pre><pre>We have not woken a task at the start of the ISR.
	xHigherPriorityTaskWoken = pdFALSE;</pre><pre>Loop until the buffer is empty.
	do
	{
Obtain a byte from the buffer.
		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</pre><pre>Post the byte.
		<a class="el" href="queue_8h.html#a5a4b46fc55ab9f63b89878b37352f521">xQueueSendToBackFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken )</a>;</pre><pre>	} while( portINPUT_BYTE( BUFFER_COUNT ) );</pre><pre>Now the buffer is empty we can switch context if necessary.
	if( xHigherPriorityTaskWoken )
	{
		taskYIELD ();
	}
 }
 </pre><p>queue. h </p>
<pre>
 portBASE_TYPE xQueueSendFromISR(
									 xQueueHandle pxQueue,
									 const void *pvItemToQueue,
									 portBASE_TYPE *pxHigherPriorityTaskWoken
								);
 </pre><p>This is a macro that calls <a class="el" href="queue_8h.html#a5f3e29eed8f166215648bc6465ebdb04">xQueueGenericSendFromISR()</a>. It is included for backward compatibility with versions of FreeRTOS.org that did not include the <a class="el" href="queue_8h.html#a5a4b46fc55ab9f63b89878b37352f521">xQueueSendToBackFromISR()</a> and <a class="el" href="queue_8h.html#a849dd669e72bfb12314f4445157c9a04">xQueueSendToFrontFromISR()</a> macros.</p>
<p>Post an item to the back of a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xQueue</em>&nbsp;</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvItemToQueue</em>&nbsp;</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pxHigherPriorityTaskWoken</em>&nbsp;</td><td><a class="el" href="queue_8h.html#a2e8236e9af01eedcbc8b67a9cb56b1db">xQueueSendFromISR()</a> will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If <a class="el" href="queue_8h.html#a2e8236e9af01eedcbc8b67a9cb56b1db">xQueueSendFromISR()</a> sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<pre>
 void vBufferISR( void )
 {
 char cIn;
 portBASE_TYPE xHigherPriorityTaskWoken;</pre><pre>We have not woken a task at the start of the ISR.
	xHigherPriorityTaskWoken = pdFALSE;</pre><pre>Loop until the buffer is empty.
	do
	{
Obtain a byte from the buffer.
		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</pre><pre>Post the byte.
		<a class="el" href="queue_8h.html#a2e8236e9af01eedcbc8b67a9cb56b1db">xQueueSendFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken )</a>;</pre><pre>	} while( portINPUT_BYTE( BUFFER_COUNT ) );</pre><pre>Now the buffer is empty we can switch context if necessary.
	if( xHigherPriorityTaskWoken )
	{
Actual macro used here is port specific.
		taskYIELD_FROM_ISR ();
	}
 }
 </pre><p>queue. h </p>
<pre>
 portBASE_TYPE xQueueGenericSendFromISR(
										   xQueueHandle	pxQueue,
										   const	void	*pvItemToQueue,
										   portBASE_TYPE	*pxHigherPriorityTaskWoken,
										   portBASE_TYPE	xCopyPosition
									   );
 </pre><p>It is preferred that the macros <a class="el" href="queue_8h.html#a2e8236e9af01eedcbc8b67a9cb56b1db">xQueueSendFromISR()</a>, <a class="el" href="queue_8h.html#a849dd669e72bfb12314f4445157c9a04">xQueueSendToFrontFromISR()</a> and <a class="el" href="queue_8h.html#a5a4b46fc55ab9f63b89878b37352f521">xQueueSendToBackFromISR()</a> be used in place of calling this function directly.</p>
<p>Post an item on a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xQueue</em>&nbsp;</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvItemToQueue</em>&nbsp;</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pxHigherPriorityTaskWoken</em>&nbsp;</td><td><a class="el" href="queue_8h.html#a5f3e29eed8f166215648bc6465ebdb04">xQueueGenericSendFromISR()</a> will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If <a class="el" href="queue_8h.html#a5f3e29eed8f166215648bc6465ebdb04">xQueueGenericSendFromISR()</a> sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xCopyPosition</em>&nbsp;</td><td>Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<pre>
 void vBufferISR( void )
 {
 char cIn;
 portBASE_TYPE xHigherPriorityTaskWokenByPost;</pre><pre>We have not woken a task at the start of the ISR.
	xHigherPriorityTaskWokenByPost = pdFALSE;</pre><pre>Loop until the buffer is empty.
	do
	{
Obtain a byte from the buffer.
		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</pre><pre>Post each byte.
		xQueueGenericSendFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );</pre><pre>	} while( portINPUT_BYTE( BUFFER_COUNT ) );</pre><pre>Now the buffer is empty we can switch context if necessary.  Note that the
name of the yield function required is port specific.
	if( xHigherPriorityTaskWokenByPost )
	{
		taskYIELD_YIELD_FROM_ISR();
	}
 }
 </pre> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Mar 27 2012 15:09:52 for Embedded Co-Design (VHDL and C) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
